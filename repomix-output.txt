This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-08T16:42:07.629Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
Aufgabe_1/index.html
Aufgabe_1/sketch.js
Aufgabe_1/style.css
Aufgabe_2/index.html
Aufgabe_2/particle.js
Aufgabe_2/sketch.js
Aufgabe_2/style.css
Aufgabe_3/index.html
Aufgabe_3/sketch.js
Aufgabe_3/style.css
Aufgabe_3/vehicle.js
Aufgabe_4/cityscape.js
Aufgabe_4/config.js
Aufgabe_4/firework.js
Aufgabe_4/index.html
Aufgabe_4/particle.js
Aufgabe_4/particlePool.js
Aufgabe_4/sketch.js
Aufgabe_4/star.js
Aufgabe_4/steeringParticle.js
Aufgabe_4/style.css
Aufgabe_5/BloodParticle.js
Aufgabe_5/BloodSystem.js
Aufgabe_5/config.js
Aufgabe_5/environment.js
Aufgabe_5/Fish.js
Aufgabe_5/index.html
Aufgabe_5/Jellyfish.js
Aufgabe_5/sketch.js
Aufgabe_5/SoundManager.js
Aufgabe_5/style.css
Aufgabe_5/UI.js
Aufwärmen/index.html
Aufwärmen/jsconfig.json
Aufwärmen/sketch_with_cursor.js
Aufwärmen/sketch.js
Aufwärmen/style.css
Einfuehrung/index.html
Einfuehrung/jsconfig.json
Einfuehrung/sketch.js
Einfuehrung/style.css
README.md

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# macOS system files
.DS_Store
.AppleDouble
.LSOverride

# macOS Thumbnails
._*

# macOS Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# macOS Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Windows thumbnail cache files
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db

# Windows Dump file
*.stackdump

# Windows Folder config file
[Dd]esktop.ini

# Windows Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# Linux
*~

# temporary files which can be created if a process still has a handle open of a deleted file
.fuse_hidden*

# KDE directory preferences
.directory

# Linux trash folder which might appear on any partition or disk
.Trash-*

# .nfs files are created when an open file is removed but is still being accessed
.nfs*

# Node.js
node_modules/
npm-debug.log
yarn-error.log

# IDEs and editors
.vscode/
.idea/
*.swp
*.swo
*.sublime-workspace

# Build outputs
dist/
build/
out/

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# public

# VuePress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: Aufgabe_1/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triviosa</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  </head>
  <body>
    <script src="sketch.js"></script>
  </body>
</html>

================
File: Aufgabe_1/sketch.js
================
/*
  Inspiration:
  Pexels.com, orange-blue-cloudy-sky
  Bildquelle: https://www.pexels.com/photo/orange-blue-cloudy-sky-158163/
*/

function setup() {
  createCanvas(600, 600);
  pixelDensity(1);
  noLoop();
  
  // Create initial orange background
  background(245, 107, 2, 20);
  
  // Function to create a noise layer
  function createNoiseLayer(noiseScale, col, blendingMode) {
    let layer = createGraphics(width, height);
    layer.pixelDensity(1);
    layer.loadPixels();
    let yoff = 0;
    
    for (let y = 0; y < height; y++) {
      let xoff = 0;
      for (let x = 0; x < width; x++) {
        let index = (x + y * width) * 4;
        let n = noise(xoff, yoff) * 255;
        
        layer.pixels[index + 0] = red(col);
        layer.pixels[index + 1] = green(col);
        layer.pixels[index + 2] = blue(col);
        layer.pixels[index + 3] = (alpha(col) * n) / 255;
        
        xoff += noiseScale;
      }
      yoff += noiseScale;
    }
    
    layer.updatePixels();
    blendMode(blendingMode);
    image(layer, 0, 0);
  }
  
  // Create all layers
  blendMode(BLEND); // Reset blend mode before starting
  createNoiseLayer(0.02, color(0, 3, 181, 100), MULTIPLY);
  createNoiseLayer(0.002, color(190, 9, 9, 90), DARKEST);
  createNoiseLayer(0.002, color(245, 156, 2, 80), LIGHTEST);
  createNoiseLayer(0.01, color(0, 0, 255, 70), SCREEN);
}

================
File: Aufgabe_1/style.css
================
html, body {
  margin: 0;
  padding: 0;
}

canvas {
  display: block;
}

================
File: Aufgabe_2/index.html
================
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/addons/p5.dom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8" />

  </head>
  <body>
    <script src="particle.js"></script>
    <script src="sketch.js"></script>
  </body>
</html>

================
File: Aufgabe_2/particle.js
================
class Leaf {
    constructor() {
      this.pos = createVector(random(width), random(-50, 0));
      this.vel = createVector(0, 0);
      this.acc = createVector(0, 0);
      this.maxspeed = random(1, 5);
      this.color = color(random([
        '#e63946',  // Red
        '#f4a261',  // Orange
        '#e9c46a',  // Yellow
        '#2a9d8f',  // Green
      ]));
      this.size = random(10, 20);
      this.shapeType = floor(random(4));
    }
  
    update() {
      // Update leaf physics
      this.vel.add(this.acc);
      this.vel.limit(this.maxspeed);
      this.pos.add(this.vel);
      this.acc.mult(0);
      this.acc.add(createVector(0, .5));  // Adjust gravity here
    }
  
    follow(vectors) {
      // Make leaf follow flow field
      let x = floor(this.pos.x / scl);
      let y = floor(this.pos.y / scl);
      let index = constrain(x + y * cols, 0, vectors.length - 1);
      let force = vectors[index];
      this.applyForce(force);
    }
  
    applyForce(force) {
      this.acc.add(force);
    }
  
    show() {
      // Display leaf
      fill(this.color);
      noStroke();
      push();
      translate(this.pos.x, this.pos.y);
      rotate(this.vel.heading() + PI / 2);
      beginShape();
      switch (this.shapeType) {
        case 0: // Shape 1 - Original Leaf
            vertex(0, -this.size);
            bezierVertex(this.size / 2, -this.size / 2, this.size / 2, this.size / 2, 0, this.size);
            bezierVertex(-this.size / 2, this.size / 2, -this.size / 2, -this.size / 2, 0, -this.size);
            break;

        case 1: // Shape 2 - Longer, thinner leaf
            vertex(0, -this.size);
            bezierVertex(this.size / 3, -this.size / 1.5, this.size / 2, this.size / 1.5, 0, this.size);
            bezierVertex(-this.size / 2, this.size / 1.5, -this.size / 3, -this.size / 1.5, 0, -this.size);
            break;

        case 2: // Shape 3 - Rounded leaf
            vertex(0, -this.size);
            bezierVertex(this.size, -this.size / 2, this.size, this.size / 2, 0, this.size);
            bezierVertex(-this.size, this.size / 2, -this.size, -this.size / 2, 0, -this.size);
            break;

        case 3: // Shape 4 - Pointed leaf with curve
            vertex(0, -this.size);
            bezierVertex(this.size / 1.5, -this.size / 3, this.size / 1.5, this.size / 2, 0, this.size);
            bezierVertex(-this.size / 1.5, this.size / 2, -this.size / 1.5, -this.size / 3, 0, -this.size);
            break;
    }

    endShape(CLOSE);
    pop();
    }
  
    edges() {
      if (this.pos.y > height  || this.pos.x > width || this.pos.x < 0) {
        this.reset();
      }
    }
  
    reset() {
      // Reset leaf to top of screen
      this.pos = createVector(random(width), random(-50, -10));
      this.vel = createVector(0, 0);
      this.acc = createVector(0, 0);
    }
  }

================
File: Aufgabe_2/sketch.js
================
let inc = 0.1;
let scl = 20;
let cols, rows;
let zoff = 0;
let particles = [];
let flowfield;
let bgImage;
let canvasWidth = 1000;
let canvasHeight = 1000;

function preload() {
  // Image credit: https://picsum.photos/images#2 (Image ID: 57)
  const imageUrl = `https://picsum.photos/id/57/${canvasWidth}/${canvasHeight}`;
  bgImage = loadImage(imageUrl);
}

function setup() {
  createCanvas(canvasWidth, canvasHeight);
  cols = floor(width / scl);
  rows = floor(height / scl);

  flowfield = new Array(cols * rows);

  for (let i = 0; i < 300; i++) {
    particles[i] = new Leaf();
  }
}

function draw() {
  image(bgImage, 0, 0, width, height);

  let yoff = 0;
  for (let y = 0; y < rows; y++) {
    let xoff = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xoff, yoff, zoff) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(0.3);
      flowfield[index] = v;

      push();
      translate(x * scl, y * scl);
      rotate(v.heading());
      stroke(255, 50);
      line(0, 0, scl, 0);
      pop();

      xoff += inc;
    }
    yoff += inc;
    zoff += 0.0001;
  }

  for (let i = 0; i < particles.length; i++) {
    particles[i].follow(flowfield);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
  }
}

================
File: Aufgabe_2/style.css
================
html, body {
  margin: 0;
  padding: 0;
}

canvas {
  display: block;
}

================
File: Aufgabe_3/index.html
================
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8" />

  </head>
  <body>
    <script src="sketch.js"></script>
    <script src="vehicle.js"></script>
  </body>
</html>

================
File: Aufgabe_3/sketch.js
================
let nebulae = [];
let stars = [];
let comets = [];
let vehicles = [];
let targetPoints = [];
let wordIndex = 0;
let attractMode = true;
let forceActive = false;
let showFpsCounter = false;
let font;

const WORDS = ['DREAM', 'MAGIC', 'CHAOS', 'SPACE', 'FUCK'];

function preload() {
	font = loadFont(
		'https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Me5Q.ttf'
	);
	attractCursor = loadImage(
		'https://img.icons8.com/?size=100&id=EDlqOuNnwBFU&format=png&color=000000'
	);
	repelCursor = loadImage(
		'https://img.icons8.com/?size=100&id=8Cpx9JrEbpOM&format=png&color=000000'
	);
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	pixelDensity(1);
	colorMode(HSB, 360, 100, 100, 1.0);
	initEffects();
	generateTextPoints(WORDS[wordIndex]);
}

function initEffects() {
	// Nebel initialisieren
	for (let i = 0; i < 5; i++) {
		nebulae.push({
			x: random(width),
			y: random(height),
			size: random(100, 300),
			hue: random(360),
			alpha: random(0.1, 0.2),
			offset: random(1000),
		});
	}

	// Sterne initialisieren
	stars = new Array(200).fill().map(() => ({
		x: random(width),
		y: random(height),
		size: random(1, 3),
	}));

	// Kometen initialisieren
	for (let i = 0; i < 10; i++) {
		createNewComet();
	}
}

function createNewComet() {
	comets.push({
		pos: createVector(random(width), random(height)),
		vel: p5.Vector.random2D().mult(random(3, 8)),
		length: random(20, 40),
		hue: random(360),
		alive: true,
		trail: [],
	});
}

function generateTextPoints(text) {
	vehicles = [];
	targetPoints = [];

	// Adjusts font size based on text length
	let fontSize = text.length > 4 ? 120 : 150;

	// Calculates text boundaries for centering
	let bounds = font.textBounds(text, 0, 0, fontSize);
	let centerX = width / 2 - bounds.w / 2;
	let centerY = height / 2 + bounds.h / 2;

	let points = font.textToPoints(text, centerX, centerY, fontSize, {
		sampleFactor: 0.1,
		simplifyThreshold: 0,
	});

	for (let p of points) {
		let vehicle = new Vehicle(random(width), random(height), p.x, p.y);
		vehicles.push(vehicle);
		targetPoints.push(createVector(p.x, p.y));
	}
}

function draw() {
	background(240, 30, 15);

	drawNebulae(1);
	drawStars();
	updateAndDrawComets();
	updateMainParticles(1);
	drawForceIndicator();

	showFps();
}

function drawNebulae() {
	noStroke();

	for (let nebula of nebulae) {
		push();
		translate(nebula.x, nebula.y);
		fill(nebula.hue, 60, 80, nebula.alpha);

		beginShape();
		for (let a = 0; a < TWO_PI; a += 0.5) {
			// Uses Perlin noise to create irregular radius
			let r =
				nebula.size * noise(cos(a) + nebula.offset, sin(a) + nebula.offset);
			let x = r * cos(a);
			let y = r * sin(a);
			vertex(x, y);
		}
		endShape(CLOSE);

		pop();
	}
}

function drawStars() {
	noStroke();
	fill(0, 0, 100, 0.8);

	for (let star of stars) {
		ellipse(star.x, star.y, 2);
	}
}

function updateAndDrawComets() {
	for (let comet of comets) {
		// Updates comet position based on its velocity
		comet.pos.add(comet.vel);

		// Draws the comet's tail using 3 gradually fading circles
		for (let i = 3; i > 0; i--) {
			let alpha = 0.3 / i;
			fill(comet.hue, 80, 100, alpha);
			ellipse(
				comet.pos.x - comet.vel.x * i * 2,
				comet.pos.y - comet.vel.y * i * 2,
				8
			);
		}

		fill(comet.hue, 80, 100);
		ellipse(comet.pos.x, comet.pos.y, 6);

		if (
			comet.pos.x < 0 ||
			comet.pos.x > width ||
			comet.pos.y < 0 ||
			comet.pos.y > height
		) {
			comet.alive = false;
		}
	}

	comets = comets.filter((c) => c.alive);
	while (comets.length < 3) {
		createNewComet();
	}
}

function updateMainParticles(intensity) {
	for (let vehicle of vehicles) {
		vehicle.move(intensity);
		vehicle.update();
		vehicle.show(intensity);
	}
}

function drawForceIndicator() {
	noCursor();
	if (forceActive) {
		let cursorImage = attractMode ? attractCursor : repelCursor;
		imageMode(CENTER);
		image(cursorImage, mouseX, mouseY, 40, 40);
	}
}

function keyPressed() {
	if (key === ' ') {
		wordIndex = (wordIndex + 1) % WORDS.length;
		generateTextPoints(WORDS[wordIndex]);
	}
	if (key === 'f') {
		showFpsCounter = !showFpsCounter;
	}
}

function showFps() {
	if (showFpsCounter) {
		fill(0, 0, 100);
		noStroke();
		text('FPS: ' + floor(frameRate()), 10, 20);
	}
}

function mousePressed() {
	if (!forceActive) {
		attractMode = true;
		forceActive = true;
	} else if (attractMode) {
		attractMode = false;
		forceActive = true;
	} else {
		forceActive = false;
	}
}

function windowResized() {
	resizeCanvas(windowWidth, windowHeight);
	generateTextPoints(WORDS[wordIndex]);
}

================
File: Aufgabe_3/style.css
================
html,
body {
	margin: 0;
	padding: 0;
}

canvas {
	display: block;
}

================
File: Aufgabe_3/vehicle.js
================
class Vehicle {
  constructor(x, y, targetX, targetY) {
      this.pos = createVector(x, y);
      this.vel = p5.Vector.random2D();
      this.acc = createVector();
      this.target = createVector(targetX, targetY);
      this.maxSpeed = random(8, 12);
      this.maxForce = random(0.8, 1.2);
      this.size = random(4, 8);
      this.color = random(360);
  }

  move() {
      let targetForce = this.getTargetForce();
      this.acc.add(targetForce);

      let wanderForce = this.getWanderForce();
      this.acc.add(wanderForce);

      if (forceActive) {
          let mouseForce = this.getMouseForce();
          this.acc.add(mouseForce);
      }
  }

  getTargetForce() {
      // Calculate vector pointing from current position to target
      let desired = p5.Vector.sub(this.target, this.pos);
      let distance = desired.mag();
      
      // Slow down when getting closer (within 100 pixels)
      let speed = distance < 100 ? map(distance, 0, 100, 0, this.maxSpeed) : this.maxSpeed;
      desired.setMag(speed);
      
      // Calculate steering force (desired minus current velocity)
      let steer = p5.Vector.sub(desired, this.vel);
      return steer.limit(this.maxForce).mult(0.6);
  }

  getWanderForce() {
      // Use Perlin noise to generate smooth random movement
      return p5.Vector.fromAngle(
          noise(this.pos.x * 0.01, this.pos.y * 0.01) * TWO_PI * 2
      ).mult(0.1);
  }

  getMouseForce() {
      // Get vector pointing from particle to mouse
      let mousePos = createVector(mouseX, mouseY);
      let force = p5.Vector.sub(mousePos, this.pos);
      // Constrain distance to prevent extreme forces
      let distance = constrain(force.mag(), 20, 100);
      
      if (!attractMode) {
          force.mult(-1);
      }
      
      force.normalize();
      let strength = 2.0 / (distance * 0.05);
      return force.mult(strength);
  }

  update() {
      this.pos.add(this.vel);
      this.vel.add(this.acc);
      this.vel.limit(this.maxSpeed);
      this.acc.mult(0);

      this.pos.x = (this.pos.x + width) % width;
      this.pos.y = (this.pos.y + height) % height;
  }

  show() {
      noStroke();
      
      // Draw multiple circles for glow effect
      // Larger circles are more transparent
      // i=3: outer glow
      // i=0: core of particle
      for (let i = 3; i >= 0; i--) {
          let alpha = i === 0 ? 0.8 : 0.3/i;
          let radius = this.size * (i * 2 || 2);
          fill(this.color, 80, 100, alpha);
          ellipse(this.pos.x, this.pos.y, radius);
      }
  }
}

================
File: Aufgabe_4/cityscape.js
================
let buildings = [];

function createCityscape() {
    const img = createGraphics(width, height/2.5);
    img.fill(20);
    img.noStroke();
    
    // Only create buildings once if they don't exist
    if (buildings.length === 0) {
        for (let x = 0; x < width; x += random(60, 120)) {
            const building = {
                x: x,
                width: random(40, 100),
                height: random(img.height * 0.3, img.height * 0.9),
                windows: []
            };
            
            const windowSize = 8;
            const windowSpacing = 15;
            const windowMargin = 10;
            
            const windowCols = floor((building.width - 2 * windowMargin) / windowSpacing);
            const windowRows = floor((building.height - 2 * windowMargin) / windowSpacing);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    building.windows.push({
                        x: building.x + windowMargin + col * windowSpacing,
                        y: img.height - building.height + windowMargin + row * windowSpacing,
                        isLit: random() < 0.7,
                        lastChange: random(0, 1000)
                    });
                }
            }
            buildings.push(building);
        }
    }
    
    // Draw buildings
    for (let building of buildings) {
        img.rect(building.x, img.height - building.height, building.width, building.height);
        
        const windowSize = 8;
        for (let window of building.windows) {
            // Only update windows occasionally
            if (frameCount - window.lastChange > 1000 && random() < 0.001) {
                window.isLit = !window.isLit;
                window.lastChange = frameCount;
            }
            
            if (window.isLit) {
                img.fill(255, 255, 0, random(40, 120));
                img.rect(window.x, window.y, windowSize, windowSize);
                img.fill(20);
            }
        }
    }
    
    return img;
}

================
File: Aufgabe_4/config.js
================
const CONFIG = {
    PARTICLE_COUNT: 100,
    STAR_COUNT: 200,
	FIREWORK_TYPES: [
		'circle', 
		'heart', 
		'spiral', 
		'text', 
		'steeringText', 
	],
    COLORS: {
        BACKGROUND: [5, 5, 20],
        STARS: [255, 255, 255]
    },
    LAUNCH_CHANCE: 0.03,
    TEXTS: ['★', '♥', '♪', '✨'],
    SOUNDS: {
        EXPLOSION: [
            'https://assets.mixkit.co/active_storage/sfx/1662/1662-preview.mp3',
            'https://assets.mixkit.co/active_storage/sfx/2800/2800-preview.mp3',  
            'https://assets.mixkit.co/active_storage/sfx/2801/2801-preview.mp3',  
            'https://assets.mixkit.co/active_storage/sfx/2802/2802-preview.mp3', 
            'https://assets.mixkit.co/active_storage/sfx/2809/2809-preview.mp3'   
        ]
    },
    PARTICLE: {
        TRAIL_LENGTH: 5,
        LIFESPAN_DECREASE: 4,
        VELOCITY_RETAIN: 0.95,
        LAUNCH_VELOCITY: {
            MIN: 12,
            MAX: 20
        }
    }
};

================
File: Aufgabe_4/firework.js
================
class Firework {
    constructor(x, y, type = random(CONFIG.FIREWORK_TYPES)) {
        if (!particlePool) {
            particlePool = new ParticlePool(2000);
        }
        
        this.type = type;
        this.hu = random(255);
        x = constrain(x, width * 0.1, width * 0.9);
        this.firework = particlePool.acquire(x, y, this.hu, true, type);
        this.exploded = false;
        this.particles = [];
        
        this.hasSecondaryExplosion = random() < 0.3;
        this.secondaryExplosionTimer = random(20, 40);
        this.sparkTrail = random() < 0.4;
        this.rotationAngle = 0;
        this.rotationSpeed = random(-0.1, 0.1);
        this.colorShift = random() < 0.3;
        this.colorShiftSpeed = random(2, 5);
    }

    createNormalParticles(count) {
        for (let i = 0; i < count; i++) {
            const p = particlePool.acquire(
                this.firework.pos.x,
                this.firework.pos.y,
                this.hu,
                false,
                'circle'
            );
            // Add some randomness to the explosion
            const angle = random(TWO_PI);
            const speed = random(2, 8);
            p.vel = p5.Vector.fromAngle(angle).mult(speed);
            this.particles.push(p);
        }
    }

    explode() {
        const explosionIndex = floor(random(explosionSounds.length));
        explosionSounds[explosionIndex].play();

        if (this.type === 'steeringText') {
            let points = this.createTextPoints();
            if (points.length > 0) {
                for (let point of points) {
                    const p = new SteeringParticle(
                        this.firework.pos.x,
                        this.firework.pos.y,
                        point.x,
                        point.y,
                        this.hu
                    );
                    this.particles.push(p);
                }
            } else {
                this.createNormalParticles(CONFIG.PARTICLE_COUNT);
            }
        } else {
            this.createEnhancedParticles();
        }
    }

    createTextPoints() {
        let points = [];
        let txt = random(['BOOM', 'POW', 'WOW', 'BAM', '2024']);
        let fontSize = 120;

        let bounds = textFont.textBounds(txt, 0, 0, fontSize);
        let centerX = this.firework.pos.x - bounds.w / 2;
        let centerY = this.firework.pos.y + bounds.h / 2;

        points = textFont.textToPoints(txt, centerX, centerY, fontSize, {
            sampleFactor: 0.1,
            simplifyThreshold: 0
        });

        points = points.map((p) => ({
            x: p.x,
            y: p.y,
        }));

        if (points.length > 300) {
            points = shuffle(points).slice(0, 300);
        }

        return points;
    }

	createEnhancedParticles() {
		const particleCount = this.type === 'text' ? 50 : CONFIG.PARTICLE_COUNT;
		
		switch(this.type) {
			case 'spiral':
				this.createSpiralParticles(particleCount);
				break;
			case 'heart':
				this.createHeartParticles(particleCount);
				break;
			case 'double':
				this.createDoubleRingParticles(particleCount);
				break;
			case 'text':
				// Create a circular explosion pattern but with text particles
				for (let i = 0; i < particleCount; i++) {
					const p = particlePool.acquire(
						this.firework.pos.x,
						this.firework.pos.y,
						this.hu,
						false,
						'text'  // This ensures the particle will use drawText()
					);
					const angle = random(TWO_PI);
					const speed = random(2, 6);
					p.vel = p5.Vector.fromAngle(angle).mult(speed);
					this.particles.push(p);
				}
				break;
			default:
				this.createNormalParticles(particleCount);
		}
	}

    createSpiralParticles(count) {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * TWO_PI * 3;
            const r = map(i, 0, count, 0, 50);
            const x = this.firework.pos.x + cos(angle) * r;
            const y = this.firework.pos.y + sin(angle) * r;
            const p = particlePool.acquire(x, y, this.hu, false, 'spiral');
            p.vel = p5.Vector.fromAngle(angle).mult(random(2, 5));
            this.particles.push(p);
        }
    }

    createHeartParticles(count) {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * TWO_PI;
            const r = 30 * (1 - sin(angle));
            const x = this.firework.pos.x + r * cos(angle);
            const y = this.firework.pos.y + r * sin(angle);
            const p = particlePool.acquire(x, y, this.hu, false, 'heart');
            this.particles.push(p);
        }
    }

    update() {
        if (!this.exploded) {
            this.firework.applyForce(gravity);
            this.firework.update();
            
            if (this.sparkTrail && frameCount % 2 === 0) {
                this.createSparkTrail();
            }

            if (this.firework.vel.y >= 0) {
                this.exploded = true;
                this.explode();
            }
        }

        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            particle.applyForce(gravity);
            
            if (this.type !== 'steeringText') {
                this.rotationAngle += this.rotationSpeed;
                const rotForce = createVector(cos(this.rotationAngle), sin(this.rotationAngle));
                rotForce.mult(0.1);
                particle.applyForce(rotForce);
            }
            
            if (this.colorShift) {
                particle.hu = (particle.hu + this.colorShiftSpeed) % 255;
            }

            particle.update();

            if (particle.done()) {
                if (this.hasSecondaryExplosion && 
                    this.secondaryExplosionTimer-- <= 0 && 
                    i === this.particles.length - 1) {
                    this.createSecondaryExplosion(particle.pos.x, particle.pos.y);
                }
                
                this.particles.splice(i, 1);
            }
        }
    }

    createSparkTrail() {
        const sparkParticle = particlePool.acquire(
            this.firework.pos.x,
            this.firework.pos.y,
            this.hu,
            false,
            'spark'
        );
        sparkParticle.lifespan = 100;
        this.particles.push(sparkParticle);
    }

    createSecondaryExplosion(x, y) {
        for (let i = 0; i < 20; i++) {
            const angle = random(TWO_PI);
            const p = particlePool.acquire(x, y, this.hu, false, 'circle');
            p.vel = p5.Vector.fromAngle(angle).mult(random(1, 3));
            p.lifespan = 150;
            this.particles.push(p);
        }
    }

    show() {
        if (!this.exploded) {
            this.firework.show();
        }

        for (let particle of this.particles) {
            if (this.type === 'spiral' || this.type === 'double') {
                blendMode(ADD);
                particle.show();
                blendMode(BLEND);
            } else {
                particle.show();
            }
            
            if (this.type === 'double' && this.particles.length > 1) {
                let nextParticle = this.particles[(this.particles.indexOf(particle) + 1) % this.particles.length];
                stroke(particle.hu, 255, 255, particle.lifespan * 0.5);
                strokeWeight(0.5);
                line(particle.pos.x, particle.pos.y, nextParticle.pos.x, nextParticle.pos.y);
            }
        }
    }

    done() {
        if (this.exploded) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                if (this.particles[i].done()) {
                    particlePool.release(this.particles[i]);
                    this.particles.splice(i, 1);
                }
            }
        }
        return this.exploded && this.particles.length === 0;
    }
}

================
File: Aufgabe_4/index.html
================
<!-- <!DOCTYPE html>
<html>
<head>
    <title>Enhanced Fireworks Display</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <div id="controls">
        <button onclick="toggleAuto()">Toggle Auto</button>
        <button onclick="toggleSound()">Toggle Sound</button>
    </div>
    <script src="config.js"></script>
    <script src="sound-manager.js"></script>
    <script src="star.js"></script>
    <script src="particle.js"></script>
    <script src="firework.js"></script>
    <script src="cityscape.js"></script>
    <script src="sketch.js"></script>
</body>
</html> -->

<!DOCTYPE html>
<html>

<head>
    <title>Enhanced Fireworks Display</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <div id="controls">
        <button onclick="toggleAuto()">Toggle Auto</button>
    </div>
    <script src="config.js"></script>
    <script src="particlePool.js"></script>
    <script src="particle.js"></script>
    <script src="steeringParticle.js"></script>
    <script src="firework.js"></script>
    <script src="star.js"></script>
    <script src="cityscape.js"></script>
    <script src="sketch.js"></script>
</body>

</html>

================
File: Aufgabe_4/particle.js
================
class Particle {
    constructor(x, y, hu, firework, type = 'circle') {
        this.reset(x, y, hu, firework, type);
    }
    
    reset(x, y, hu, firework, type = 'circle') {
        this.pos = createVector(x, y);
        this.firework = firework;
        this.lifespan = 255;
        this.hu = hu;
        this.type = type;
        this.acc = createVector(0, 0);
        this.trail = [];
        
        if (firework) {
            const angle = random(-PI/6, PI/6);
            this.vel = p5.Vector.fromAngle(angle - HALF_PI)
                .mult(random(CONFIG.PARTICLE.LAUNCH_VELOCITY.MIN, 
                           CONFIG.PARTICLE.LAUNCH_VELOCITY.MAX));
        } else {
            this.vel = p5.Vector.random2D();
            this.vel.mult(random(2, 10));
        }
        return this;
    }
    
    applyForce(force) {
        this.acc.add(force);
    }
    
    update() {
        if (!this.firework) {
            this.vel.mult(CONFIG.PARTICLE.VELOCITY_RETAIN);
            this.lifespan -= CONFIG.PARTICLE.LIFESPAN_DECREASE;
            
            if (this.trail.length < CONFIG.PARTICLE.TRAIL_LENGTH) {
                this.trail.push(this.pos.copy());
            } else {
                this.trail.shift();
                this.trail.push(this.pos.copy());
            }
        }
        
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.acc.mult(0);
    }
    
    show() {
        colorMode(HSB);
        
        if (!this.firework) {
            this.drawTrail();
            this.drawParticle();
        } else {
            strokeWeight(4);
            stroke(this.hu, 255, 255);
            point(this.pos.x, this.pos.y);
        }
    }
    
    drawTrail() {
        for (let i = 0; i < this.trail.length - 1; i++) {
            const alpha = map(i, 0, this.trail.length - 1, 0, this.lifespan);
            stroke(this.hu, 255, 255, alpha);
            line(this.trail[i].x, this.trail[i].y, 
                 this.trail[i + 1].x, this.trail[i + 1].y);
        }
    }
    
    drawParticle() {
        strokeWeight(2);
        stroke(this.hu, 255, 255, this.lifespan);
        
        switch(this.type) {
            case 'heart':
                this.drawHeart();
                break;
            case 'text':
                this.drawText();
                break;
            case 'spiral':
                this.drawSpiral();
                break;
            default:
                point(this.pos.x, this.pos.y);
        }
    }
    
    drawHeart() {
        push();
        translate(this.pos.x, this.pos.y);
        scale(0.3);
        beginShape();
        vertex(0, -5);
        bezierVertex(-5, -5, -5, 0, 0, 5);
        bezierVertex(5, 0, 5, -5, 0, -5);
        endShape(CLOSE);
        pop();
    }
    
    drawText() {
        textSize(40);
        textAlign(CENTER, CENTER);
        text(random(CONFIG.TEXTS), this.pos.x, this.pos.y);
    }
    
    drawSpiral() {
        const angle = frameCount * 0.1;
        const radius = 5;
        const x = this.pos.x + cos(angle) * radius;
        const y = this.pos.y + sin(angle) * radius;
        point(x, y);
    }
    
    done() {
        return this.lifespan < 0;
    }
}

================
File: Aufgabe_4/particlePool.js
================
class ParticlePool {
    constructor(maxSize = 1000) {
        this.maxSize = maxSize;
        this.pool = new Array(maxSize).fill(null);
        this.nextAvailable = 0;
        
        // prefill particle pool
        for (let i = 0; i < maxSize; i++) {
            this.pool[i] = new Particle(0, 0, 0, false);
        }
    }

    acquire(x, y, hu, firework, type) {
        // create new particle if pool is exhausted
        if (this.nextAvailable >= this.maxSize) {
            console.warn('Pool erschöpft - erstelle neuen Partikel');
            return new Particle(x, y, hu, firework, type);
        }

        // take particle from pool and initialize it
        const particle = this.pool[this.nextAvailable++];
        particle.reset(x, y, hu, firework, type);
        return particle;
    }

    release(particle) {
        // put particle back into pool
        if (this.nextAvailable <= 0) return;
        
        this.nextAvailable--;
        this.pool[this.nextAvailable] = particle;
    }
}

================
File: Aufgabe_4/sketch.js
================
let fireworks = [];
let stars = [];
let gravity;
let autoLaunch = true;
let soundEnabled = false;
let cityscape;
let explosionSounds = [];
let particlePool;

function preload() {
	textFont = loadFont(
		'https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Me5Q.ttf'
	);
	// Load all explosion sounds
	for (let explosionURL of CONFIG.SOUNDS.EXPLOSION) {
		let sound = loadSound(explosionURL);
		sound.setVolume(0.2);
		explosionSounds.push(sound);
	}
}

function setup() {
	createCanvas(windowWidth, windowHeight);
	colorMode(HSB);
	gravity = createVector(0, 0.2);
	particlePool = new ParticlePool(2000);

	// Initialize stars
	for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
		stars.push(new Star(random(width), random(height / 2)));
	}

	cityscape = createCityscape();
}

function draw() {
	colorMode(RGB);
	background(...CONFIG.COLORS.BACKGROUND, 25);

	// Draw stars
	for (let star of stars) star.show();

	// Draw cityscape
	image(cityscape, 0, height - cityscape.height);

	// Auto-launch fireworks
	if (autoLaunch && random(1) < CONFIG.LAUNCH_CHANCE) {
		launchFirework(random(width), height);
	}

	// Update cityscape every 60 frames (about 1 second)
	if (frameCount % 60 === 0) {
		cityscape = createCityscape();
	}

	// Update and show fireworks
	for (let i = fireworks.length - 1; i >= 0; i--) {
		fireworks[i].update();
		fireworks[i].show();

		if (fireworks[i].done()) {
			fireworks.splice(i, 1);
		}
	}
}

function mousePressed() {
	if (mouseY < height - 100) {
		launchFirework(mouseX, mouseY);
	}
}

function launchFirework(x, y) {
	x = constrain(x, width * 0.1, width * 0.9);
	let type = random(CONFIG.FIREWORK_TYPES);
	fireworks.push(new Firework(x, y, type));
}

function toggleAuto() {
	autoLaunch = !autoLaunch;
}

function toggleSound() {
	soundEnabled = !soundEnabled;
	// Initialize audio context with user interaction
	if (soundEnabled && getAudioContext().state !== 'running') {
		getAudioContext().resume();
	}
}

function windowResized() {
	resizeCanvas(windowWidth, windowHeight);
	cityscape = createCityscape();
}

================
File: Aufgabe_4/star.js
================
class Star {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = random(0.5, 2);
        this.twinkleSpeed = random(0.02, 0.05);
        this.angle = random(TWO_PI);
    }
    
    show() {
        this.angle += this.twinkleSpeed;
        const twinkle = map(sin(this.angle), -1, 1, 0.5, 1);
        
        fill(255, 255, 255, 255 * twinkle);
        noStroke();
        ellipse(this.x, this.y, this.size);
    }
}

================
File: Aufgabe_4/steeringParticle.js
================
class SteeringParticle {
    constructor(x, y, targetX, targetY, hu) {
        this.pos = createVector(x, y);
        
        this.vel = createVector(targetX - x, targetY - y);
        this.vel.normalize();
        this.vel.mult(2);
        
        this.acc = createVector();
        this.target = createVector(targetX, targetY);
        this.maxSpeed = 4;
        this.maxForce = 0.4;
        this.hu = hu;
        this.r = 3;
        this.lifespan = 255;
        this.reached = false;
        
        this.dampening = 0.98;
    }

    behaviors() {
        let arrive = this.arrive(this.target);
        this.applyForce(arrive);
    }

    applyForce(f) {
        this.acc.add(f);
    }

    arrive(target) {
        let desired = p5.Vector.sub(target, this.pos);
        let d = desired.mag();
        let speed = this.maxSpeed;
        
        if (d < 30) {
            speed = map(d, 0, 30, 0, this.maxSpeed);
        }
        
        desired.setMag(speed);
        let steer = p5.Vector.sub(desired, this.vel);
        steer.limit(this.maxForce);
        return steer;
    }

    update() {
        if (!this.reached) {
            this.behaviors();
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            
            // Apply dampening
            this.vel.mult(this.dampening);
            
            this.pos.add(this.vel);
            this.acc.mult(0);
            
            // Only consider reached if very close and moving very slowly
            if (p5.Vector.dist(this.pos, this.target) < 2 && this.vel.mag() < 0.1) {
                this.reached = true;
                // Snap to final position
                this.pos = this.target.copy();
            }
        }
        
        this.lifespan -= 1;
    }

    show() {
        colorMode(HSB);
        strokeWeight(this.r);
        stroke(this.hu, 255, 255, this.lifespan);
        point(this.pos.x, this.pos.y);
    }

    done() {
        return this.lifespan < 0;
    }
}

================
File: Aufgabe_4/style.css
================
body { 
    margin: 0; 
    overflow: hidden;
    background: #000;
}

#controls {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 5px;
    z-index: 1000;
}

button {
    background: #333;
    color: white;
    border: none;
    padding: 8px 16px;
    margin: 0 5px;
    cursor: pointer;
    border-radius: 3px;
    transition: background 0.3s;
}

button:hover {
    background: #444;
}

button:active {
    background: #222;
}

================
File: Aufgabe_5/BloodParticle.js
================
class BloodParticle {
    constructor(x, y) {
        this.pos = createVector(x, y);
        this.vel = p5.Vector.random2D().mult(random(1, 3));
        this.acc = createVector(0, 0.1); // Gravity-like effect
        this.lifespan = 255; // Particle lifespan
    }

    update() {
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.lifespan -= 5; // Fade out over time
    }

    draw() {
        noStroke();
        fill(255, 0, 0, this.lifespan); // Red color with alpha for fading
        ellipse(this.pos.x, this.pos.y, 5); // Small blood droplet
    }

    isDead() {
        return this.lifespan <= 0;
    }
}

================
File: Aufgabe_5/BloodSystem.js
================
class BloodSystem {
    constructor(x, y) {
        this.particles = [];
        this.origin = createVector(x, y);
    }

    addParticle() {
        for (let i = 0; i < 10; i++) { // Generate multiple particles at once
            this.particles.push(new BloodParticle(this.origin.x, this.origin.y));
        }
    }

    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].isDead()) {
                this.particles.splice(i, 1); // Remove dead particles
            }
        }
    }

    draw() {
        this.particles.forEach(particle => particle.draw());
    }
}

================
File: Aufgabe_5/config.js
================
const CONFIG = {
    FISH: {
        DEFAULT_PREY_SPEED: 1,
        DEFAULT_SHARK_SPEED: 1,
        DEFAULT_PREY_SIZE: 15,
        DEFAULT_SHARK_SIZE: 30,
        PREY_PERCEPTION: 120,
        SHARK_PERCEPTION: 180,
        INITIAL_PREY_COUNT: 90,
        INITIAL_SHARK_COUNT: 2,
        PREY_TURN_SPEED: 0.08,
        SHARK_TURN_SPEED: 0.05,
        JELLYFISH_AVOIDANCE: 100
    },
    JELLYFISH: {
        COUNT: 5,
        MIN_SIZE: 40,
        MAX_SIZE: 80,
        SPEED: 0.5,
        PULSE_RATE: 0.02
    },
    ENVIRONMENT: {
        WATER_RIPPLE_SPEED: 0.02,
        WATER_RIPPLE_SCALE: 100,
        NIGHT_COLOR: [10, 20, 40],
        DAY_COLOR: [200, 220, 255],
        PLANKTON_DENSITY: 50,
        BUBBLE_RATE: 0.1
    }
};

================
File: Aufgabe_5/environment.js
================
class Environment {
    constructor() {
        this.plankton = [];
        this.bubbles = [];
        this.waterRays = [];
        this.nightMode = false;
        this.waterOffset = 0;
    }

    update() {
        this.updateBubbles();
        this.updatePlankton();
        if (!this.nightMode) {
            this.updateWaterRays();
        }
        this.waterOffset += 0.02;  // For ripple animation
    }

    draw() {
        this.drawBackground();
        this.drawWaterRipples();
        if (!this.nightMode) {
            this.drawWaterRays();
        }
        this.drawBubbles();
        this.drawPlankton();
    }

    drawBackground() {
        console.log("Drawing background, nightMode:", this.nightMode);
        let bgColor = this.nightMode ? color(20, 30, 50) : color(40, 100, 150);
        background(bgColor);
    }

    drawWaterRipples() {
        noFill();
        stroke(255, this.nightMode ? 15 : 30);
        for (let i = 0; i < height; i += 50) {
            beginShape();
            for (let x = 0; x < width; x += 10) {
                let y = i + sin(x * 0.01 + this.waterOffset) * 20;
                vertex(x, y);
            }
            endShape();
        }
    }

    drawWaterRays() {
        noStroke();
        for (let i = 0; i < width; i += 50) {
            let rayHeight = height * 0.7;
            let alpha = map(sin(frameCount * 0.02 + i * 0.01), -1, 1, 0.05, 0.15);
            fill(60, 10, 100, alpha);
            beginShape();
            vertex(i, 0);
            vertex(i + 30, 0);
            vertex(i + random(-100, 100), rayHeight);
            vertex(i + random(-100, 100), rayHeight);
            endShape(CLOSE);
        }
    }

    updateBubbles() {
        if (random(1) < CONFIG.ENVIRONMENT.BUBBLE_RATE) {
            this.bubbles.push({
                x: random(width),
                y: height,
                size: random(2, 8),
                speed: random(1, 3)
            });
            console.log("Bubble created"); // Debug log
        }
    
        for (let i = this.bubbles.length - 1; i >= 0; i--) {
            let bubble = this.bubbles[i];
            bubble.y -= bubble.speed;
            bubble.x += sin(frameCount * 0.1 + bubble.y * 0.1) * 0.5;
            if (bubble.y < 0) {
                this.bubbles.splice(i, 1);
                console.log("Bubble removed"); // Debug log
            }
        }
    }

    drawBubbles() {
        noStroke();
        fill(255, 255, 255, 0.8); // Bright white bubbles
        this.bubbles.forEach(bubble => {
            ellipse(bubble.x, bubble.y, bubble.size);
        });
    }

    updatePlankton() {
        while (this.plankton.length < CONFIG.ENVIRONMENT.PLANKTON_DENSITY) {
            this.plankton.push({
                x: random(width),
                y: random(height),
                size: random(2, 4)
            });
        }
    }
    
    drawPlankton() {
        noStroke();
        fill(50, 200, 50, this.nightMode ? 0.7 : 0.4); // Bright green plankton
        this.plankton.forEach(p => {
            let flicker = random(0.8, 1.2);
            ellipse(p.x, p.y, p.size * flicker);
        });
    }
}

================
File: Aufgabe_5/Fish.js
================
class Fish {
    constructor(isShark = false) {
        this.pos = createVector(random(width), random(height));
        this.vel = p5.Vector.random2D();
        this.acc = createVector();
        this.r = isShark ? 15 : 8; // Size based on type
        this.maxSpeed = isShark ? CONFIG.FISH.DEFAULT_SHARK_SPEED : CONFIG.FISH.DEFAULT_PREY_SPEED; // Slider controlled
        this.maxForce = isShark ? 0.3 : 0.15;
        this.isShark = isShark;
        this.health = 100;
        this.image = isShark ? predatorImages[0] : preyImages[0]; // Image for visualization
    }

    update(fishes, jellyfishes) {
        if (this.isShark) {
            this.hunt(fishes); // Sharks hunt prey
        } else {
            this.flock(fishes); // Preys flock together
        }

        this.avoidJellyfish(jellyfishes); // Avoid jellyfish for both sharks and preys
        this.vel.add(this.acc);
        this.vel.limit(this.maxSpeed); // Respect max speed slider
        this.pos.add(this.vel);
        this.acc.mult(0); // Reset acceleration
        this.edges();
    }

    applyForce(force) {
        this.acc.add(force);
    }

    flock(fishes) {
        let sep = this.separate(fishes).mult(1.5); // Separation
        let ali = this.align(fishes).mult(1.0); // Alignment
        let coh = this.cohere(fishes).mult(1.0); // Cohesion

        this.applyForce(sep);
        this.applyForce(ali);
        this.applyForce(coh);
    }

    hunt(fishes) {
        let target = null;
        let minDist = CONFIG.FISH.SHARK_PERCEPTION;

        for (let fish of fishes) {
            if (!fish.isShark) {
                let d = p5.Vector.dist(this.pos, fish.pos);
                if (d < minDist) {
                    minDist = d;
                    target = fish;
                }
            }
        }

        if (target) {
            let desired = p5.Vector.sub(target.pos, this.pos).setMag(this.maxSpeed);
            let steer = p5.Vector.sub(desired, this.vel).limit(this.maxForce);
            this.applyForce(steer);

            // Simulate eating if close enough
            if (minDist < this.r + target.r) {
                fishes.splice(fishes.indexOf(target), 1); // Remove the prey
            }
        }
    }

    avoidJellyfish(jellyfishes) {
        let steer = createVector(0, 0);
        let count = 0;

        for (let jelly of jellyfishes) {
            let d = p5.Vector.dist(this.pos, jelly.pos);
            if (d < CONFIG.FISH.JELLYFISH_AVOIDANCE + jelly.size) {
                let diff = p5.Vector.sub(this.pos, jelly.pos).normalize().div(d);
                steer.add(diff);
                count++;
            }
        }

        if (count > 0) {
            steer.div(count).setMag(this.maxSpeed).sub(this.vel).limit(this.maxForce);
            this.applyForce(steer);
        }
    }

    separate(fishes) {
        let desiredSeparation = 25;
        let steer = createVector(0, 0);
        let count = 0;

        for (let fish of fishes) {
            let d = p5.Vector.dist(this.pos, fish.pos);
            if (d > 0 && d < desiredSeparation) {
                let diff = p5.Vector.sub(this.pos, fish.pos).normalize().div(d);
                steer.add(diff);
                count++;
            }
        }

        if (count > 0) steer.div(count).setMag(this.maxSpeed).sub(this.vel).limit(this.maxForce);
        return steer;
    }

    align(fishes) {
        let neighborDist = 50;
        let sum = createVector(0, 0);
        let count = 0;

        for (let fish of fishes) {
            let d = p5.Vector.dist(this.pos, fish.pos);
            if (d > 0 && d < neighborDist && !fish.isShark) {
                sum.add(fish.vel);
                count++;
            }
        }

        if (count > 0) sum.div(count).setMag(this.maxSpeed).sub(this.vel).limit(this.maxForce);
        return sum;
    }

    cohere(fishes) {
        let neighborDist = 50;
        let sum = createVector(0, 0);
        let count = 0;

        for (let fish of fishes) {
            let d = p5.Vector.dist(this.pos, fish.pos);
            if (d > 0 && d < neighborDist && !fish.isShark) {
                sum.add(fish.pos);
                count++;
            }
        }

        if (count > 0) {
            sum.div(count);
            return this.seek(sum);
        }
        return createVector(0, 0);
    }

    seek(target) {
        let desired = p5.Vector.sub(target, this.pos).setMag(this.maxSpeed);
        let steer = p5.Vector.sub(desired, this.vel).limit(this.maxForce);
        return steer;
    }

    edges() {
        if (this.pos.x < -this.r) this.pos.x = width + this.r;
        if (this.pos.x > width + this.r) this.pos.x = -this.r;
        if (this.pos.y < -this.r) this.pos.y = height + this.r;
        if (this.pos.y > height + this.r) this.pos.y = -this.r;
    }

    draw(isNightMode) {
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.vel.heading());
        if (this.image) {
            if (isNightMode) {
                drawingContext.shadowBlur = 15;
                drawingContext.shadowColor = this.isShark ? 'red' : 'blue';
            }
            imageMode(CENTER);
            image(this.image, 0, 0, this.r * 2, this.r * 2);
        }
        pop();
    }
}

================
File: Aufgabe_5/index.html
================
<!DOCTYPE html>
<html>
<head>
    <title>Ocean Ecosystem</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="config.js"></script>
    <script src="SoundManager.js"></script>
    <script src="Fish.js"></script>
    <script src="Jellyfish.js"></script>
    <script src="BloodParticle.js"></script>
    <script src="BloodSystem.js"></script>
    <script src="environment.js"></script>
    <script src="UI.js"></script>
    <script src="sketch.js"></script>
</body>
</html>

================
File: Aufgabe_5/Jellyfish.js
================
class Jellyfish {
    constructor() {
        this.pos = createVector(random(width), random(height));
        this.vel = p5.Vector.random2D();
        this.acc = createVector();
        this.size = random(CONFIG.JELLYFISH.MIN_SIZE, CONFIG.JELLYFISH.MAX_SIZE);
        this.phase = random(TWO_PI);
        this.image = random(jellyfishImages); // Randomly select an image
    }

    update() {
        // Random drift movement using Perlin noise
        let noise1 = noise(this.pos.x * 0.01, this.pos.y * 0.01, frameCount * 0.01);
        let noise2 = noise(this.pos.x * 0.01, this.pos.y * 0.01, frameCount * 0.01 + 1000);
        
        this.vel.x = map(noise1, 0, 1, -CONFIG.JELLYFISH.SPEED, CONFIG.JELLYFISH.SPEED);
        this.vel.y = map(noise2, 0, 1, -CONFIG.JELLYFISH.SPEED, CONFIG.JELLYFISH.SPEED);
        
        this.pos.add(this.vel);
        this.edges(); // Handle edge behavior

        // Update phase for pulsing animation
        this.phase += CONFIG.JELLYFISH.PULSE_RATE;
    }

    draw(isNightMode) {
        push();
        translate(this.pos.x, this.pos.y);

        // Add glow in night mode
        if (isNightMode) {
            drawingContext.shadowBlur = 30;
            drawingContext.shadowColor = 'cyan';
        }

        // Draw the image scaled to the size
        tint(255, 10, 80); 
        imageMode(CENTER);
        image(this.image, 0, 0, this.size, this.size);

        pop();
    }

    edges() {
        if (this.pos.x < this.size / 2 || this.pos.x > width - this.size / 2) {
            this.vel.x *= -1; // Reverse horizontal velocity
            this.pos.x = constrain(this.pos.x, this.size / 2, width - this.size / 2);
        }
        if (this.pos.y < this.size / 2 || this.pos.y > height - this.size / 2) {
            this.vel.y *= -1; // Reverse vertical velocity
            this.pos.y = constrain(this.pos.y, this.size / 2, height - this.size / 2);
        }
    }
}

================
File: Aufgabe_5/sketch.js
================
let environment;
let soundManager;
let ui;
let fish = [];
let jellyfishes = [];

if (typeof CONFIG === 'undefined') {
    console.error('CONFIG is not defined! Make sure constants.js is loaded first.');
}

function preload() {
    soundManager = new SoundManager();
    soundManager.preload();
    predatorImages = [
        loadImage('https://img.icons8.com/?size=100&id=dNyJV4Qw3AEk&format=png&color=000000'),
    ]
    preyImages = [
        loadImage('https://img.icons8.com/?size=100&id=ridRyeBSIgrH&format=png&color=000000'),
    ]
    jellyfishImages = [
        loadImage('https://img.icons8.com/?size=100&id=ywdnn5QiqsYg&format=png&color=000000'),
    ]
}


function setup() {
    createCanvas(windowWidth, windowHeight);
    environment = new Environment();
    console.log(environment);
    ui = new UI({
        onFishSpeedChange: updateFishSpeed,
        onSharkSpeedChange: updateSharkSpeed,
        onVolumeChange: (vol) => soundManager.setVolume(vol),
        onAddFish: () => addNewFish(false),
        onAddShark: () => addNewFish(true),
        onAddJellyfish: addJellyfish,
        onNightModeToggle: toggleNightMode,
        onReset: resetSimulation
    });
    initializeSimulation();
    soundManager.startAmbient();
}

function initializeSimulation() {
    // Initialize with fish
    for (let i = 0; i < CONFIG.FISH.INITIAL_PREY_COUNT; i++) {
        fish.push(new Fish(false));
    }

    // Initialize with sharks
    for (let i = 0; i < CONFIG.FISH.INITIAL_SHARK_COUNT; i++) {
        fish.push(new Fish(true));
    }

    // Initialize with jellyfish
    for (let i = 0; i < CONFIG.JELLYFISH.COUNT; i++) {
        jellyfishes.push(new Jellyfish());
    }
}

function draw() {
    try {
        let bgColor = environment.nightMode ? color(20, 30, 50) : color(40, 100, 150);
        background(bgColor);

        environment.draw();

        // Draw jellyfishes
        jellyfishes.forEach((jelly, index) => {
            if (!jelly || typeof jelly.draw !== 'function') {
                console.error(`Jellyfish at index ${index} is invalid:`, jelly);
            } else {
                jelly.update();
                jelly.draw(environment.nightMode);
            }
        });

        // Draw fish
        fish.forEach((f, index) => {
            if (!f || typeof f.draw !== 'function') {
                console.error(`Fish at index ${index} is invalid:`, f);
            } else {
                f.update(fish, jellyfishes);
                f.draw(environment.nightMode);
            }
        });

        // Update stats in the UI
        ui.updateStats({
            fishCount: fish.filter(f => !f.isShark).length,
            sharkCount: fish.filter(f => f.isShark).length,
            jellyfishCount: jellyfishes.length
        });

    } catch (error) {
        console.error("Error in draw():", error);
        noLoop();
    }
}


function addNewFish(isShark) {
    let newFish = new Fish(isShark);
    newFish.pos = createVector(mouseX, mouseY);
    fish.push(newFish);
    soundManager.playSound('splash');
}

function updateFishSpeed(value) {
    console.log("Fish speed slider value:", value); // Debugging
    fish.forEach(f => {
        if (!f.isShark) {
            f.maxSpeed = value; // Update speed for non-sharks
            console.log("Updated fish maxSpeed:", f.maxSpeed); // Debugging
        }
    });
}


function updateSharkSpeed(value) {
    fish.forEach(f => {
        if (f.isShark) {
            f.maxSpeed = value;
        }
    });
}

function addJellyfish() {
    let jelly = new Jellyfish();
    jelly.pos = createVector(mouseX, mouseY);
    jellyfishes.push(jelly);
    soundManager.playSound('bubble');
}

function toggleNightMode() {
    environment.nightMode = !environment.nightMode;
}

function resetSimulation() {
    fish = [];
    jellyfishes = [];
    initializeSimulation();
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
    if (mouseX < 200 && mouseY < 300) return; // Ignore UI area
    if (mouseButton === LEFT) addNewFish(false);
    if (mouseButton === RIGHT) addNewFish(true);
}

function keyPressed() {
    switch (key) {
        case 'f': addNewFish(false); break;
        case 's': addNewFish(true); break;
        case 'j': addJellyfish(); break;
        case 'n': toggleNightMode(); break;
        case 'r': resetSimulation(); break;
    }
}

================
File: Aufgabe_5/SoundManager.js
================
class SoundManager {
    constructor() {
        this.sounds = {};
        this.volume = 0.5;
        this.soundsEnabled = false;
        this.loadingComplete = false;
    }

    preload() {
        console.log('Bypassing sound preload for debugging.');
        this.loadingComplete = true;
    }

    setVolume(volume) {
        if (!this.soundsEnabled) return;
        
        this.volume = volume;
        Object.values(this.sounds).forEach(sound => {
            if (sound && sound.setVolume) {
                sound.setVolume(volume);
            }
        });
    }

    playSound(name) {
        if (!this.soundsEnabled) return;
        
        const sound = this.sounds[name];
        if (sound) {
            if (name !== 'ambient' && sound.isPlaying && sound.isPlaying()) {
                sound.stop();
            }
            if (sound.play) {
                sound.play();
            }
        }
    }

    startAmbient() {
        if (!this.soundsEnabled) return;
        
        const ambient = this.sounds.ambient;
        if (ambient && !ambient.isPlaying()) {
            ambient.setVolume(this.volume * 0.3);
            ambient.loop();
        }
    }

    stopAll() {
        if (!this.soundsEnabled) return;
        
        Object.values(this.sounds).forEach(sound => {
            if (sound && sound.isPlaying()) {
                sound.stop();
            }
        });
    }
}

================
File: Aufgabe_5/style.css
================
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: white;
}

canvas {
    border: 2px solid black;
    z-index: 10;
}

.slider-container {
    position: fixed;
    bottom: 20px; /* Align at the bottom */
    left: 20px; /* Align at the left */
    display: flex; /* Display sliders horizontally */
    gap: 15px; /* Add spacing between sliders */
    background: rgba(255, 255, 255, 0.8); /* Light background */
    padding: 10px;
    border-radius: 5px;
    z-index: 1000;
}

.slider-container .slider-wrapper {
    display: flex;
    flex-direction: column; /* Align label and slider vertically */
    align-items: center; /* Center-align the slider and label */
}

.slider-container input {
    width: 120px;
}

.button-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 5px;
    margin-top: 10px;
}

.control-panel {
    background: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border-radius: 8px;
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 1000;
    color: white; /* Add this */
}

.stat {
    color: white; /* Add this */
    margin: 5px 0;
}

/* Tooltip styles */
.tooltip {
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
}

================
File: Aufgabe_5/UI.js
================
class UI {
    constructor(callbacks) {
        this.callbacks = callbacks;
        this.panel = this.setupUI();
        colorMode(RGB);
    }

    setupUI() {
        let panel = createDiv('');
        panel.class('control-panel'); // For top-left stats/buttons
        this.statsDiv = createDiv('');
        this.statsDiv.class('stats');
        this.statsDiv.parent(panel);
    
        // Slider container for bottom-left sliders
        let sliderContainer = createDiv('');
        sliderContainer.class('slider-container'); // Bottom-left sliders
        this.createSlider(sliderContainer, 'Fish Speed', 1, 5, 1, 0.1, 
            value => this.callbacks.onFishSpeedChange(value));
        this.createSlider(sliderContainer, 'Shark Speed', 1, 5, 1, 0.1,
            value => this.callbacks.onSharkSpeedChange(value));
        this.createSlider(sliderContainer, 'Volume', 0, 1, 0.5, 0.1,
            value => this.callbacks.onVolumeChange(value));
    
        // Buttons container remains in top-left
        let buttonDiv = createDiv('');
        buttonDiv.class('button-container');
        buttonDiv.parent(panel);
    
        // Create buttons
        this.createButton(buttonDiv, '🐟 Add Fish', () => this.callbacks.onAddFish());
        this.createButton(buttonDiv, '🦈 Add Shark', () => this.callbacks.onAddShark());
        this.createButton(buttonDiv, '🎐 Add Jellyfish', () => this.callbacks.onAddJellyfish());
        this.createButton(buttonDiv, '🌙 Toggle Night Mode', () => this.callbacks.onNightModeToggle());
        this.createButton(buttonDiv, '🔄 Reset', () => this.callbacks.onReset());
    
        return panel;
    }
    

    createSlider(parent, label, min, max, value, step, callback) {
        let wrapper = createDiv('');
        wrapper.class('slider-wrapper');
        wrapper.parent(parent);
    
        // Add label
        createSpan(label).parent(wrapper);
    
        // Create slider
        let slider = createSlider(min, max, value, step);
        slider.input(() => {
            console.log(`${label} slider changed to:`, slider.value()); // Add this for debugging
            callback(slider.value());
        });
        slider.parent(wrapper);
    
        // Add value display
        let valueDisplay = createSpan(value.toFixed(1));
        valueDisplay.parent(wrapper);
        slider.input(() => valueDisplay.html(slider.value().toFixed(1)));
    }
    

    createButton(parent, label, callback) {
        let btn = createButton(label);
        btn.parent(parent);
        btn.mousePressed(callback);
        return btn;
    }

    updateStats(stats) {
        this.statsDiv.html(`
            <div class="stat">🐟 Fish: ${stats.fishCount}</div>
            <div class="stat">🦈 Sharks: ${stats.sharkCount}</div>
            <div class="stat">🎐 Jellyfish: ${stats.jellyfishCount}</div>
        `);
    }
}

================
File: Aufwärmen/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triviosa</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  </head>
  <body>
    <script src="sketch.js"></script>
  </body>
</html>

================
File: Aufwärmen/jsconfig.json
================
{
  "compilerOptions": {
    "target": "es6"
  },
  "include": [
    "*.js",
    "**/*.js",
    "c:\\Users\\vioan\\.vscode\\extensions\\samplavigne.p5-vscode-1.2.16\\p5types\\global.d.ts"
  ]
}

================
File: Aufwärmen/sketch_with_cursor.js
================
let noiseFactor = 0.05;  // Control noise scale
let canvasSize = 400;

function setup() {
  createCanvas(canvasSize, canvasSize); 
  // frameRate(10);
  noCursor();
}
  // noLoop() // sodass der Canvas nicht in einem Loop ständig gezeichnet wird
  // updatePixels();
  function draw() {
    background(255);  // Clear background each frame
  
    // First, draw the Perlin Noise background, but make it responsive to mouse movement
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let noiseValue = noise(x * noiseFactor, y * noiseFactor);
        
        // Calculate distance from the mouse
        let d = dist(x, y, mouseX, mouseY);
  
        // Move colors away from the mouse based on distance
        let maxDistance = 100;  // Maximum distance for the effect to apply
        let moveFactor = map(d, 0, maxDistance, 5, 0);  // Move color based on distance from mouse
        
        // Default colors
        let r = noiseValue * 255;
        let g = noiseValue * 100;
        let b = 200;
  
        // Modify the colors based on distance from the mouse
        if (d < maxDistance) {
          r += moveFactor * 30;  // Shift the red channel away from mouse
          g += moveFactor * 20;  // Shift the green channel away from mouse
          b += moveFactor * 10;  // Shift the blue channel away from mouse
        }
  
        // Set pixel color
        stroke(r, g, b, 150);  // Semi-transparent color
        point(x, y);
      }
    }
  
    // Draw the "purple color" at the mouse position
    noStroke();
    fill(150, 0, 255);  // Purple color
    ellipse(mouseX, mouseY, 20, 20);  // The mouse is represented as a purple circle
}
  //
  //
  // noStroke (um Rand vom Kreisen zu entfernen)
  // fill("blue") oder fill(0, 255, 255, 100) - und der letze Wert bestimmt die Intensität (ob durchsichtig oder nicht)
  //
  // let c1 = color(0, 255, 255)
  // let c2 = color(255, 0, 255)
  //
  // fill(c1)
  // circle(windowHeight/2-300, windowWidth/2, 200)
  // 
  // fill(lerpColor(c1, c2, 0.5)) - um eine Mischfarbe zwischen c1 und c2 zu bekommen. Je höher die Zahl desto näher an der andere Farbe
  // circle(windowHeight/2, windowWidth/2, 200)
  //
  // fill(c2)
  // circle(windowHeight/2+300, windowWidth/2, 200)



  // if (mouseIsPressed === true) {
  //   fill(0);
  // } else {
  //   fill(255);
  // }
  // circle(mouseX, mouseY, 100);

================
File: Aufwärmen/sketch.js
================
var tex

function setup() {
  createCanvas(windowWidth, windowHeight); 
  pixelDensity(1) // es muss vor loadPixels kommen, sonst wird es nicht funktionieren
  // callback um Ränder zu vermeiden beim resizen
  // noLoop() sodass der Canvas nicht in einem Loop ständig gezeichnet wird

  tex = createImage(400, 400)
  tex.loadPixels()
  for(let y = 0; y < tex.width; y++){
    for(let x = 0; x < tex.height; x++){
      let index = 4 * (y * tex.width +x);
      pixels[index+0]= map(x, 0, tex.width, 0, 255)
      pixels[index+1]= map(y, 0, tex.height, 0, 255)
      pixels[index+2]= 0
      pixels[index+3]= 255
    }
  }
  tex.updatePixels()
}

function draw() {
  background("green");

  image(tex, mouseX, mouseY)
  // blendMode(DIFFERENCE) um blendmodes zu benutzen
  //
  //
  // noStroke (um Rand vom Kreisen zu entfernen)
  // fill("blue") oder fill(0, 255, 255, 100) - und der letze Wert bestimmt die Intensität (ob durchsichtig oder nicht)
  //
  // let c1 = color(0, 255, 255)
  // let c2 = color(255, 0, 255)
  //
  // fill(c1)
  // circle(windowHeight/2-300, windowWidth/2, 200)
  // 
  // fill(lerpColor(c1, c2, 0.5)) - um eine Mischfarbe zwischen c1 und c2 zu bekommen. Je höher die Zahl desto näher an der andere Farbe
  // circle(windowHeight/2, windowWidth/2, 200)
  //
  // fill(c2)
  // circle(windowHeight/2+300, windowWidth/2, 200)



  // if (mouseIsPressed === true) {
  //   fill(0);
  // } else {
  //   fill(255);
  // }
  // circle(mouseX, mouseY, 100);
}

================
File: Aufwärmen/style.css
================
html, body {
  margin: 0;
  padding: 0;
}

canvas {
  display: block;
}

================
File: Einfuehrung/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triviosa</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  </head>
  <body>
    <script src="sketch.js"></script>
  </body>
</html>

================
File: Einfuehrung/jsconfig.json
================
{
  "compilerOptions": {
    "target": "es6"
  },
  "include": [
    "*.js",
    "**/*.js",
    "c:\\Users\\vioan\\.vscode\\extensions\\samplavigne.p5-vscode-1.2.16\\p5types\\global.d.ts"
  ]
}

================
File: Einfuehrung/sketch.js
================
var tex

function setup() {
  createCanvas(windowWidth, windowHeight); 
  pixelDensity(1) // es muss vor loadPixels kommen, sonst wird es nicht funktionieren
  // callback um Ränder zu vermeiden beim resizen
  // noLoop() sodass der Canvas nicht in einem Loop ständig gezeichnet wird

  tex = createImage(400, 400)
  tex.loadPixels()
  for(let y = 0; y < tex.width; y++){
    for(let x = 0; x < tex.height; x++){
      let index = 4 * (y * tex.width +x);
      pixels[index+0]= map(x, 0, tex.width, 0, 255)
      pixels[index+1]= map(y, 0, tex.height, 0, 255)
      pixels[index+2]= 0
      pixels[index+3]= 255
    }
  }
  tex.updatePixels()
}

function draw() {
  background("green");

  image(tex, mouseX, mouseY)
  // blendMode(DIFFERENCE) um blendmodes zu benutzen
  //
  //
  // noStroke (um Rand vom Kreisen zu entfernen)
  // fill("blue") oder fill(0, 255, 255, 100) - und der letze Wert bestimmt die Intensität (ob durchsichtig oder nicht)
  //
  // let c1 = color(0, 255, 255)
  // let c2 = color(255, 0, 255)
  //
  // fill(c1)
  // circle(windowHeight/2-300, windowWidth/2, 200)
  // 
  // fill(lerpColor(c1, c2, 0.5)) - um eine Mischfarbe zwischen c1 und c2 zu bekommen. Je höher die Zahl desto näher an der andere Farbe
  // circle(windowHeight/2, windowWidth/2, 200)
  //
  // fill(c2)
  // circle(windowHeight/2+300, windowWidth/2, 200)



  // if (mouseIsPressed === true) {
  //   fill(0);
  // } else {
  //   fill(255);
  // }
  // circle(mouseX, mouseY, 100);
}

================
File: Einfuehrung/style.css
================
html, body {
  margin: 0;
  padding: 0;
}

canvas {
  display: block;
}

================
File: README.md
================
# generative-gestaltung
